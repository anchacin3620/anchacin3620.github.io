<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Trayectoria Balística - RK4 (Mejorado)</title>
    <style>
        /* --- Estilos CSS3 --- */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f0f2f5;
            color: #333;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        .container {
            background-color: #ffffff;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 1200px;
            margin: 40px auto;
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 30px;
            flex-grow: 1;
        }

        h1 {
            grid-column: 1 / -1;
            text-align: center;
            color: #1a237e;
            margin-top: 0;
            margin-bottom: 10px;
        }

        .subtitle {
            grid-column: 1 / -1;
            text-align: center;
            font-size: 0.9em;
            color: #555;
            margin-bottom: 20px;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        .control-group label {
            margin-bottom: 5px;
            font-weight: 600;
            font-size: 0.9em;
        }

        .control-group input, .control-group select {
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 1em;
            background-color: #fff;
        }

        /* Estilo para inputs inválidos */
        .control-group input.invalid {
            border-color: #e74c3c;
            background-color: #fceaea;
        }

        .control-group input[type="range"] {
            cursor: pointer;
        }

        .range-value {
            text-align: center;
            font-weight: bold;
            color: #1a237e;
        }
        
        .buttons-group {
            display: flex;
            gap: 10px;
        }

        .buttons-group button {
            flex-grow: 1;
            padding: 15px;
            background-color: #3949ab;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .buttons-group button:hover {
            background-color: #303f9f;
        }
        
        .buttons-group #exportBtn {
            background-color: #27ae60;
        }
        
        .buttons-group #exportBtn:hover {
            background-color: #229954;
        }

        .visualization {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        #trajectoryCanvas {
            border: 2px solid #ddd;
            border-radius: 5px;
            width: 100%;
            background-color: #fafafa;
        }

        .results {
            background-color: #e8eaf6;
            padding: 15px;
            border-radius: 5px;
            border-left: 5px solid #3949ab;
        }

        .results h3 {
            margin-top: 0;
            color: #1a237e;
        }

        .results p {
            margin: 5px 0;
            font-family: "Courier New", Courier, monospace;
        }
        
        /* --- Estilos para el Footer --- */
        footer {
            background-color: #2c3e50;
            color: #ecf0f1;
            text-align: center;
            padding: 20px;
            margin-top: auto;
            font-size: 0.9em;
        }

        footer p {
            margin: 5px 0;
            line-height: 1.5;
        }

        footer a {
            color: #3498db;
            text-decoration: none;
        }

        footer a:hover {
            text-decoration: underline;
        }

        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
                margin: 20px auto;
            }
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>Simulador de Trayectoria Balística</h1>
        <p class="subtitle">Método de Integración Numérica Runge-Kutta de Cuarto Orden (RK4)</p>

        <div class="controls">
            <!-- NUEVO: Selector de Presets -->
            <div class="control-group">
                <label for="preset">Presets de Objetos</label>
                <select id="preset">
                    <option value="custom">Personalizado</option>
                    <option value="cannonball">Bala de Cañón (Esfera)</option>
                    <option value="tennisball">Pelota de Tenis</option>
                    <option value="arrow">Flecha</option>
                </select>
            </div>

            <div class="control-group">
                <label for="mass">Masa (m) [kg]</label>
                <input type="number" id="mass" value="0.01" step="0.001" min="0.001">
            </div>
            <div class="control-group">
                <label for="velocity">Velocidad Inicial (v₀) [m/s]</label>
                <input type="number" id="velocity" value="300" step="1" min="1">
            </div>
            <div class="control-group">
                <label for="angle">Ángulo de Lanzamiento (θ) [grados]</label>
                <input type="range" id="angle" value="30" min="0" max="90">
                <div class="range-value" id="angleValue">30°</div>
            </div>
            <div class="control-group">
                <label for="dragCoeff">Coeficiente de Arrastre (C<sub>D</sub>)</label>
                <input type="number" id="dragCoeff" value="0.295" step="0.01" min="0">
            </div>
            <div class="control-group">
                <label for="area">Área Transversal (A) [m²]</label>
                <input type="number" id="area" value="0.000034" step="0.000001" min="0.000001">
            </div>
            <div class="control-group">
                <label for="density">Densidad del Aire (ρ) [kg/m³]</label>
                <input type="number" id="density" value="1.225" step="0.01" min="0.1">
            </div>
            
            <!-- NUEVO: Grupo de botones -->
            <div class="buttons-group">
                <button id="simulateBtn">Simular Trayectoria</button>
                <button id="exportBtn">Exportar a CSV</button>
            </div>
        </div>

        <div class="visualization">
            <canvas id="trajectoryCanvas" width="700" height="400"></canvas>
            <div class="results">
                <h3>Resultados de la Simulación</h3>
                <p><strong>Alcance Máximo (R):</strong> <span id="rangeResult">-</span> m</p>
                <p><strong>Altura Máxima (H<sub>max</sub>):</strong> <span id="heightResult">-</span> m</p>
                <p><strong>Tiempo de Vuelo (t):</strong> <span id="timeResult">-</span> s</p>
            </div>
        </div>
    </div>

    <footer>
        <p><strong>Elaborado por el Profesor Ángel Chacín Ávila</strong></p>
        <p>Licenciado en Física, Especialista en Ciencias Computacionales, Diplomado en Educación Policial</p>
        <p>Docente e Investigador de la Universidad Nacional Experimental de la Seguridad Núcleo Zulia</p>
        <p>@2025 - Se publica bajo licencia <a href="https://www.gnu.org/licenses/gpl-3.0.html" target="_blank" rel="noopener noreferrer">GPLv3</a></p>
    </footer>

    <script>
        // --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
        // --- LÓGICA Y ALGORITMOS (JavaScript) - Corazón del Simulador
        // --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---

        // Variable global para almacenar el resultado de la última simulación
        let lastSimulationResult = null;

        // --- NUEVO: Datos de los Presets ---
        const presets = {
            custom: {}, // No hace nada, para la opción "Personalizado"
            cannonball: { mass: 4.5, dragCoeff: 0.47, area: 0.018, velocity: 200, angle: 45 },
            tennisball: { mass: 0.058, dragCoeff: 0.51, area: 0.0035, velocity: 60, angle: 35 },
            arrow: { mass: 0.020, dragCoeff: 0.02, area: 0.0001, velocity: 70, angle: 40 }
        };

        // --- NUEVO: Modularización del Código ---
        const PhysicsEngine = {
            g: 9.81, // Aceleración gravitacional [m/s²]
            dt: 0.01, // Paso de tiempo (Δt) para la integración [s]

            toRadians(degrees) {
                return degrees * (Math.PI / 180);
            },

            derivatives(state, params) {
                const { x, y, vx, vy } = state;
                const { m, Cd, A, rho } = params;
                const v = Math.sqrt(vx * vx + vy * vy);
                if (v === 0) return { dxdt: 0, dydt: 0, dvxdt: 0, dvydt: -this.g };
                const Fd = 0.5 * rho * Cd * A * v * v;
                const ax = -(Fd / m) * (vx / v);
                const ay = -this.g - (Fd / m) * (vy / v);
                return { dxdt: vx, dydt: vy, dvxdt: ax, dvydt: ay };
            },

            rk4Step(state, params, h) {
                const k1 = this.derivatives(state, params);
                const state2 = { x: state.x + 0.5 * h * k1.dxdt, y: state.y + 0.5 * h * k1.dydt, vx: state.vx + 0.5 * h * k1.dvxdt, vy: state.vy + 0.5 * h * k1.dvydt };
                const k2 = this.derivatives(state2, params);
                const state3 = { x: state.x + 0.5 * h * k2.dxdt, y: state.y + 0.5 * h * k2.dydt, vx: state.vx + 0.5 * h * k2.dvxdt, vy: state.vy + 0.5 * h * k2.dvydt };
                const k3 = this.derivatives(state3, params);
                const state4 = { x: state.x + h * k3.dxdt, y: state.y + h * k3.dydt, vx: state.vx + h * k3.dvxdt, vy: state.vy + h * k3.dvydt };
                const k4 = this.derivatives(state4, params);
                return {
                    x: state.x + (h / 6.0) * (k1.dxdt + 2 * k2.dxdt + 2 * k3.dxdt + k4.dxdt),
                    y: state.y + (h / 6.0) * (k1.dydt + 2 * k2.dydt + 2 * k3.dydt + k4.dydt),
                    vx: state.vx + (h / 6.0) * (k1.dvxdt + 2 * k2.dvxdt + 2 * k3.dvxdt + k4.dvxdt),
                    vy: state.vy + (h / 6.0) * (k1.dvydt + 2 * k2.dvydt + 2 * k3.dvydt + k4.dvydt),
                };
            },

            calculateTrajectory(params) {
                const trajectory = [];
                const angleRad = this.toRadians(params.angle);
                let state = { x: 0, y: 0, vx: params.v0 * Math.cos(angleRad), vy: params.v0 * Math.sin(angleRad) };
                let time = 0;
                let maxHeight = 0;
                while (state.y >= 0) {
                    trajectory.push({ x: state.x, y: state.y });
                    if (state.y > maxHeight) maxHeight = state.y;
                    state = this.rk4Step(state, params, this.dt);
                    time += this.dt;
                    if (time > 100) break;
                }
                if (trajectory.length > 0 && state.y < 0) {
                    const lastPoint = trajectory[trajectory.length - 1];
                    const prevPoint = trajectory[trajectory.length - 2];
                    const t = prevPoint.y / (prevPoint.y - state.y);
                    const impactX = prevPoint.x + t * (state.x - prevPoint.x);
                    trajectory.push({ x: impactX, y: 0 });
                }
                return { points: trajectory, maxHeight: maxHeight, time: time };
            }
        };

        const Renderer = {
            canvas: null,
            ctx: null,

            init() {
                this.canvas = document.getElementById('trajectoryCanvas');
                this.ctx = this.canvas.getContext('2d');
            },

            drawTrajectory(trajectory) {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                if (trajectory.length < 2) return;

                const maxX = Math.max(...trajectory.map(p => p.x));
                const maxY = Math.max(...trajectory.map(p => p.y));
                const padding = 40;
                const scaleX = (this.canvas.width - 2 * padding) / maxX;
                const scaleY = (this.canvas.height - 2 * padding) / maxY;
                const scale = Math.min(scaleX, scaleY);

                const toCanvasCoords = (x, y) => {
                    return { x: padding + x * scale, y: this.canvas.height - padding - y * scale };
                };
                
                // NUEVO: Dibujar cuadrícula
                this.ctx.strokeStyle = '#e0e0e0';
                this.ctx.lineWidth = 0.5;
                const gridSpacingPixels = 50;
                for (let x = padding; x < this.canvas.width - padding; x += gridSpacingPixels) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, padding);
                    this.ctx.lineTo(x, this.canvas.height - padding);
                    this.ctx.stroke();
                }
                for (let y = padding; y < this.canvas.height - padding; y += gridSpacingPixels) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(padding, y);
                    this.ctx.lineTo(this.canvas.width - padding, y);
                    this.ctx.stroke();
                }

                // Dibujar ejes
                this.ctx.strokeStyle = '#999';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                this.ctx.moveTo(padding, this.canvas.height - padding);
                this.ctx.lineTo(this.canvas.width - padding, this.canvas.height - padding);
                this.ctx.moveTo(padding, this.canvas.height - padding);
                this.ctx.lineTo(padding, padding);
                this.ctx.stroke();

                // NUEVO: Dibujar etiquetas de ejes
                this.ctx.fillStyle = '#555';
                this.ctx.font = '12px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('Distancia (m)', this.canvas.width / 2, this.canvas.height - 10);
                this.ctx.save();
                this.ctx.translate(15, this.canvas.height / 2);
                this.ctx.rotate(-Math.PI / 2);
                this.ctx.fillText('Altura (m)', 0, 0);
                this.ctx.restore();
                
                // Dibujar la trayectoria
                this.ctx.strokeStyle = '#3949ab';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                const startCoords = toCanvasCoords(trajectory[0].x, trajectory[0].y);
                this.ctx.moveTo(startCoords.x, startCoords.y);
                for (let i = 1; i < trajectory.length; i++) {
                    const coords = toCanvasCoords(trajectory[i].x, trajectory[i].y);
                    this.ctx.lineTo(coords.x, coords.y);
                }
                this.ctx.stroke();
            }
        };

        const UIController = {
            init() {
                // Asignar listeners para actualización en tiempo real
                const controlsToUpdate = ['mass', 'velocity', 'angle', 'dragCoeff', 'area', 'density'];
                controlsToUpdate.forEach(id => {
                    document.getElementById(id).addEventListener('input', () => this.runSimulation());
                });

                // Listener para el slider del ángulo
                const angleSlider = document.getElementById('angle');
                angleSlider.addEventListener('input', (event) => {
                    document.getElementById('angleValue').textContent = `${event.target.value}°`;
                });

                // Listener para el botón de simulación
                document.getElementById('simulateBtn').addEventListener('click', () => this.runSimulation());
                
                // NUEVO: Listener para los presets
                document.getElementById('preset').addEventListener('change', (e) => this.handlePresetChange(e));

                // NUEVO: Listener para el botón de exportación
                document.getElementById('exportBtn').addEventListener('click', () => this.exportToCSV());
            },

            getParams() {
                return {
                    m: parseFloat(document.getElementById('mass').value),
                    v0: parseFloat(document.getElementById('velocity').value),
                    angle: parseFloat(document.getElementById('angle').value),
                    Cd: parseFloat(document.getElementById('dragCoeff').value),
                    A: parseFloat(document.getElementById('area').value),
                    rho: parseFloat(document.getElementById('density').value)
                };
            },

            // NUEVO: Función de validación de entradas
            validateParams(params) {
                let isValid = true;
                const inputs = document.querySelectorAll('.control-group input');
                inputs.forEach(input => input.classList.remove('invalid'));

                if (isNaN(params.m) || params.m <= 0) {
                    document.getElementById('mass').classList.add('invalid');
                    isValid = false;
                }
                if (isNaN(params.v0) || params.v0 <= 0) {
                    document.getElementById('velocity').classList.add('invalid');
                    isValid = false;
                }
                if (isNaN(params.angle) || params.angle < 0 || params.angle > 90) {
                    document.getElementById('angle').classList.add('invalid');
                    isValid = false;
                }
                if (isNaN(params.Cd) || params.Cd < 0) {
                    document.getElementById('dragCoeff').classList.add('invalid');
                    isValid = false;
                }
                if (isNaN(params.A) || params.A <= 0) {
                    document.getElementById('area').classList.add('invalid');
                    isValid = false;
                }
                if (isNaN(params.rho) || params.rho <= 0) {
                    document.getElementById('density').classList.add('invalid');
                    isValid = false;
                }
                
                if (!isValid) {
                    alert("Por favor, corrija los valores resaltados en rojo. Todos deben ser números positivos y dentro de un rango lógico.");
                }
                return isValid;
            },

            displayResults(result) {
                const finalX = result.points[result.points.length - 1].x;
                document.getElementById('rangeResult').textContent = finalX.toFixed(2);
                document.getElementById('heightResult').textContent = result.maxHeight.toFixed(2);
                document.getElementById('timeResult').textContent = result.time.toFixed(2);
            },
            
            // NUEVO: Manejador de cambios en el selector de presets
            handlePresetChange(e) {
                const selectedPreset = presets[e.target.value];
                if (selectedPreset) {
                    Object.keys(selectedPreset).forEach(key => {
                        const element = document.getElementById(key);
                        if (element) {
                            element.value = selectedPreset[key];
                            if (key === 'angle') {
                                document.getElementById('angleValue').textContent = `${selectedPreset[key]}°`;
                            }
                        }
                    });
                    this.runSimulation();
                }
            },

            // NUEVO: Función para exportar a CSV
            exportToCSV() {
                if (!lastSimulationResult || lastSimulationResult.points.length === 0) {
                    alert("No hay datos de simulación para exportar. Por favor, ejecuta una simulación primero.");
                    return;
                }
                let csvContent = "data:text/csv;charset=utf-8,";
                csvContent += "x,y\n";
                lastSimulationResult.points.forEach(point => {
                    csvContent += `${point.x.toFixed(2)},${point.y.toFixed(2)}\n`;
                });
                const encodedUri = encodeURI(csvContent);
                const link = document.createElement("a");
                link.setAttribute("href", encodedUri);
                link.setAttribute("download", "trayectoria_balistica.csv");
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            },

            runSimulation() {
                const params = this.getParams();
                if (!this.validateParams(params)) {
                    return; // Detener la simulación si la validación falla
                }
                
                const result = PhysicsEngine.calculateTrajectory(params);
                lastSimulationResult = result; // Guardar el resultado para la exportación
                
                Renderer.drawTrajectory(result.points);
                this.displayResults(result);
            }
        };

        // --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
        // --- INICIALIZACIÓN DE LA APLICACIÓN
        // --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
        
        window.onload = () => {
            Renderer.init();
            UIController.init();
            UIController.runSimulation(); // Ejecutar simulación inicial
        };

    </script>
</body>
</html>
