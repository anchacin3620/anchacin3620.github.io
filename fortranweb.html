<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KMC Simulation Web</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Space+Grotesk:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #050508;
            --bg-card: #0f1014;
            --fg: #e4e4e7;
            --muted: #71717a;
            --accent-cr: #4ade80; /* Green for Cr */
            --accent-fe: #fb923c; /* Orange for Fe */
            --border: #27272a;
            --surface: #18181b;
        }

        body {
            font-family: 'Space Grotesk', sans-serif;
            background: var(--bg);
            color: var(--fg);
        }

        .font-mono {
            font-family: 'JetBrains Mono', monospace;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: var(--bg); }
        ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--muted); }

        /* Canvas container */
        #canvas-container {
            position: relative;
            background: radial-gradient(circle at center, #111118 0%, #050508 100%);
            border: 1px solid var(--border);
            border-radius: 12px;
            overflow: hidden;
        }

        /* Control Inputs */
        .ctrl-input {
            background: var(--surface);
            border: 1px solid var(--border);
            color: var(--fg);
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.875rem;
            transition: border-color 0.2s;
        }
        .ctrl-input:focus {
            outline: none;
            border-color: var(--accent-cr);
        }

        /* Status Badges */
        .status-badge {
            display: inline-flex;
            align-items: center;
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: 600;
            letter-spacing: 0.05em;
            text-transform: uppercase;
        }
        .status-running { background: rgba(74, 222, 128, 0.15); color: #4ade80; animation: pulse 2s infinite; }
        .status-idle { background: rgba(113, 113, 122, 0.15); color: #71717a; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* Metric Card */
        .metric-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .metric-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        /* Progress bar */
        .progress-bar {
            height: 4px;
            background: var(--border);
            border-radius: 2px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: var(--accent-cr);
            transition: width 0.1s linear;
        }

        /* Visualization styles */
        .grid-viz {
            image-rendering: pixelated;
        }
    </style>
</head>
<body class="min-h-screen text-gray-200">

    <!-- Main Layout -->
    <div class="container mx-auto p-4 lg:p-6">
        <header class="mb-6 border-b border-zinc-800 pb-4">
            <div class="flex justify-between items-end">
                <div>
                    <h1 class="text-2xl font-bold tracking-tight">KMC Simulation</h1>
                    <p class="text-sm text-zinc-500 font-mono">simulation_kmc_unificado.f90 -> WebPort</p>
                </div>
                <div id="status-badge" class="status-badge status-idle">Idle</div>
            </div>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-12 gap-6">
            
            <!-- Left Panel: Controls -->
            <aside class="lg:col-span-3 space-y-4">
                <div class="bg-zinc-900/50 border border-zinc-800 rounded-lg p-4">
                    <h2 class="text-sm font-bold text-zinc-400 mb-3 uppercase tracking-wider">Configuracion</h2>
                    
                    <div class="space-y-4">
                        <!-- Material -->
                        <div>
                            <label class="block text-xs text-zinc-500 mb-1">Material</label>
                            <select id="input-material" class="ctrl-input w-full">
                                <option value="1">Cromo (Cr)</option>
                                <option value="2">Hierro (Fe)</option>
                            </select>
                        </div>

                        <!-- Modo Deposicion -->
                        <div>
                            <label class="block text-xs text-zinc-500 mb-1">Modo Deposicion</label>
                            <select id="input-modo" class="ctrl-input w-full">
                                <option value="1">Termico</option>
                                <option value="2">Balistico</option>
                                <option value="3">Aleatorio</option>
                            </select>
                        </div>

                        <!-- Events -->
                        <div>
                            <label class="block text-xs text-zinc-500 mb-1">Max Eventos</label>
                            <input type="number" id="input-events" class="ctrl-input w-full" value="5000" step="1000">
                        </div>

                        <!-- Corridas -->
                        <div>
                            <label class="block text-xs text-zinc-500 mb-1">Corridas</label>
                            <input type="number" id="input-corridas" class="ctrl-input w-full" value="1">
                        </div>

                        <button id="btn-start" class="w-full bg-white text-black font-bold py-2.5 rounded-lg hover:bg-zinc-200 transition-colors mt-2">
                            INICIAR SIMULACION
                        </button>
                    </div>
                </div>

                <!-- Logs -->
                <div class="bg-zinc-900/50 border border-zinc-800 rounded-lg p-4 h-48 overflow-hidden flex flex-col">
                    <h2 class="text-sm font-bold text-zinc-400 mb-2 uppercase tracking-wider">Consola</h2>
                    <div id="log-container" class="flex-1 overflow-y-auto text-xs font-mono text-zinc-500 space-y-1">
                        <div>Sistema listo.</div>
                    </div>
                </div>
            </aside>

            <!-- Center: Visualization -->
            <main class="lg:col-span-6 space-y-4">
                <div id="canvas-container" class="aspect-square w-full max-h-[600px] flex items-center justify-center bg-black">
                    <canvas id="sim-canvas" class="grid-viz w-full h-full"></canvas>
                </div>
                
                <!-- Progress -->
                <div>
                    <div class="flex justify-between text-xs font-mono text-zinc-500 mb-1">
                        <span>Eventos: <span id="val-events">0</span></span>
                        <span>Tiempo Sim: <span id="val-time">0.00</span>s</span>
                        <span><span id="val-progress">0</span>%</span>
                    </div>
                    <div class="progress-bar">
                        <div id="progress-fill" class="progress-fill" style="width: 0%"></div>
                    </div>
                </div>
            </main>

            <!-- Right Panel: Metrics -->
            <aside class="lg:col-span-3 space-y-3">
                <h2 class="text-sm font-bold text-zinc-400 uppercase tracking-wider">Metricas Avanzadas</h2>
                
                <div class="metric-card">
                    <div class="text-xs text-zinc-500 mb-1">Depositos / Difusiones</div>
                    <div class="flex justify-between font-mono text-lg">
                        <span id="val-dep">0</span>
                        <span class="text-zinc-600">/</span>
                        <span id="val-dif">0</span>
                    </div>
                </div>

                <div class="metric-card">
                    <div class="text-xs text-zinc-500 mb-1">Densidad de Islas</div>
                    <div class="font-mono text-xl" id="val-dens">0.000</div>
                </div>

                <div class="metric-card">
                    <div class="text-xs text-zinc-500 mb-1">Tamano Promedio Islas</div>
                    <div class="font-mono text-xl" id="val-size">0.00</div>
                </div>

                <div class="metric-card">
                    <div class="text-xs text-zinc-500 mb-1">Cobertura Fraccional</div>
                    <div class="font-mono text-xl" id="val-cov">0.00 %</div>
                </div>

                <div class="metric-card">
                    <div class="text-xs text-zinc-500 mb-1">Rugosidad RMS (capas)</div>
                    <div class="font-mono text-xl" id="val-rms">0.000</div>
                </div>

                <div class="metric-card">
                    <div class="text-xs text-zinc-500 mb-1">Anisotropia Superficial</div>
                    <div class="font-mono text-xl" id="val-aniso">0.000</div>
                </div>

                <div class="metric-card">
                    <div class="text-xs text-zinc-500 mb-1">Longitud Difusion Prom.</div>
                    <div class="font-mono text-xl" id="val-diflen">0.000</div>
                </div>
            </aside>
        </div>
    </div>

    <script>
        /**
         * PUERTO WEB DE SIMULATION_KMC_UNIFICADO
         * Traducido de Fortran 90 a JavaScript
         */

        // --- CONSTANTES Y PARAMETROS (Del codigo original) ---
        const TAM_REJILLA = 50;
        const ALTURA_MAX = 30;
        const KB = 8.617E-5;
        const TEMP_SUBSTRATO = 500.0;
        const TEMP_PLASMA = 1000.0;
        const INTERVALO_SNAPSHOT = 1000;

        // Parametros de materiales
        const MATERIAL_PROPS = {
            1: { name: 'Cr', ADHESION_BASE: 0.98, E_DIF_MIN: 0.01, E_DIF_MAX: 0.25 },
            2: { name: 'Fe', ADHESION_BASE: 0.95, E_DIF_MIN: 0.5, E_DIF_MAX: 1.0 }
        };

        // Modos depositcion
        const MODO_PROPS = {
            1: { name: 'Termico', energia: 2.0, tasa: 50000.0 },
            2: { name: 'Balistico', energia: 5.0, tasa: 20000.0 },
            3: { name: 'Aleatorio' } // Se calculan aleatorios
        };

        // --- ESTADO DE LA SIMULACION ---
        let state = {
            material: [], // Array 3D [x][y][z]
            altura_max_local: [], // Array 2D [x][y]
            running: false,
            paused: false,
            
            // Contadores
            num_eventos: 0,
            depositos: 0,
            difusiones: 0,
            tiempo: 0.0,
            
            // Parametros actuales
            params: {}
        };

        // --- ELEMENTOS DOM ---
        const canvas = document.getElementById('sim-canvas');
        const ctx = canvas.getContext('2d');
        const btnStart = document.getElementById('btn-start');
        const logContainer = document.getElementById('log-container');

        // --- INICIALIZACION ---
        function inicializar_rejilla() {
            // Crea arrays vacios
            state.material = new Array(TAM_REJILLA).fill(null).map(() => 
                new Array(TAM_REJILLA).fill(null).map(() => 
                    new Array(ALTURA_MAX).fill(0)
                )
            );
            
            state.altura_max_local = new Array(TAM_REJILLA).fill(null).map(() => 
                new Array(TAM_REJILLA).fill(2)
            );

            // Sustrato base
            for(let i=0; i<TAM_REJILLA; i++) {
                for(let j=0; j<TAM_REJILLA; j++) {
                    state.material[i][j][0] = -1; // Sustrato
                    state.material[i][j][1] = -1; // Sustrato
                }
            }
            
            // Reset contadores
            state.num_eventos = 0;
            state.depositos = 0;
            state.difusiones = 0;
            state.tiempo = 0.0;
        }

        // --- FUNCIONES AUXILIARES MATEMATICAS ---
        function find_z_max(x, y) {
            const col = state.material[x][y];
            for(let k=ALTURA_MAX-1; k>=0; k--) {
                if(col[k] > 0) return k;
            }
            return 0; // Sustrato es 0 y 1, asi que si no hay depositos es 0
        }

        function safeRandom() {
            let r = Math.random();
            return Math.max(1E-10, Math.min(1 - 1E-10, r));
        }

        // --- LOGICA DE SIMULACION (KMC) ---
        function simular_evento() {
            if (state.num_eventos >= state.params.MAX_EVENTOS) return false;

            state.num_eventos++;
            
            // Avance temporal
            let r_tiempo = safeRandom();
            state.tiempo += (-Math.log(r_tiempo) / state.params.tasa_eventos);

            // Tasas
            let total_rate = state.params.tasa_eventos + state.params.prob_difusion_const * (TAM_REJILLA * TAM_REJILLA);
            let r = safeRandom();

            if (r < state.params.tasa_eventos / total_rate) {
                // --- DEPOSITO ---
                let x = Math.floor(safeRandom() * TAM_REJILLA);
                let y = Math.floor(safeRandom() * TAM_REJILLA);

                // Buscar altura maxima alrededor (simplificado del original)
                // Original usaba MAXVAL sobre rango. Aqui chequeamos vecinos.
                let z_max = state.altura_max_local[x][y];
                
                // Chequeo vecinos para encontrar max height local "visible"
                for(let di=-1; di<=1; di++) {
                    for(let dj=-1; dj<=1; dj++) {
                        let nx = x + di;
                        let ny = y + dj;
                        if(nx >= 0 && nx < TAM_REJILLA && ny >= 0 && ny < TAM_REJILLA) {
                            if(state.altura_max_local[nx][ny] > z_max) 
                                z_max = state.altura_max_local[nx][ny];
                        }
                    }
                }

                // Energia y probabilidad
                let energia = state.params.energia_promedio + (safeRandom() - 0.5) * 5.0;
                let prob_adhesion = state.params.adhesion * (1.0 + (energia / 5.0) * 0.2);

                if (safeRandom() < prob_adhesion && z_max < ALTURA_MAX - 1) {
                    state.depositos++;
                    state.material[x][y][z_max + 1] = state.params.MATERIAL_ID;
                    state.altura_max_local[x][y] = z_max + 1;
                }

            } else {
                // --- DIFUSION ---
                let x = Math.floor(safeRandom() * TAM_REJILLA);
                let y = Math.floor(safeRandom() * TAM_REJILLA);
                let z_max = state.altura_max_local[x][y];

                // Solo difunden atomos depositados (no sustrato)
                if (z_max > 2 && state.material[x][y][z_max] > 0) {
                    if (safeRandom() < state.params.prob_difusion_const) {
                        // Direccion
                        let dir = Math.floor(safeRandom() * 4);
                        let nuevo_x = x, nuevo_y = y;
                        
                        if (dir === 0) nuevo_x = (x - 1 + TAM_REJILLA) % TAM_REJILLA;
                        else if (dir === 1) nuevo_x = (x + 1) % TAM_REJILLA;
                        else if (dir === 2) nuevo_y = (y - 1 + TAM_REJILLA) % TAM_REJILLA;
                        else nuevo_y = (y + 1) % TAM_REJILLA;

                        // Verificar movimiento valido
                        if (state.altura_max_local[nuevo_x][nuevo_y] == z_max - 1) {
                            // Realizar difusion
                            state.material[nuevo_x][nuevo_y][z_max] = state.material[x][y][z_max];
                            state.material[x][y][z_max] = 0;
                            state.altura_max_local[x][y] = z_max - 1;
                            state.altura_max_local[nuevo_x][nuevo_y] = z_max;
                            state.difusiones++;
                        }
                    }
                }
            }

            return true;
        }

        // --- METRICAS (Calculos avanzados) ---
        function calcular_mecanismos() {
            // Simplificacion: cuenta de atomos en superficie
            let visitado = new Array(TAM_REJILLA).fill(null).map(() => new Array(TAM_REJILLA).fill(0));
            let num_islas = 0;
            let total_atomos_sup = 0;

            // BFS para islas (Simplificado para rendimiento web)
            for(let i=0; i<TAM_REJILLA; i++) {
                for(let j=0; j<TAM_REJILLA; j++) {
                    let h = state.altura_max_local[i][j];
                    if (visitado[i][j] == 0 && state.material[i][j][h] > 0) {
                        // Encontrado nueva isla
                        num_islas++;
                        let cola = [[i,j]];
                        visitado[i][j] = 1;
                        let tam_isla = 0;

                        while(cola.length > 0) {
                            let [cx, cy] = cola.shift();
                            tam_isla++;

                            // Vecinos
                            let vecinos = [[cx-1,cy], [cx+1,cy], [cx,cy-1], [cx,cy+1]];
                            for(let [vx, vy] of vecinos) {
                                // Periodic bounds
                                vx = (vx + TAM_REJILLA) % TAM_REJILLA;
                                vy = (vy + TAM_REJILLA) % TAM_REJILLA;
                                
                                let vh = state.altura_max_local[vx][vy];
                                if (visitido[vx][vy] == 0 && state.material[vx][vy][vh] > 0) {
                                    visitado[vx][vy] = 1;
                                    cola.push([vx, vy]);
                                }
                            }
                        }
                        total_atomos_sup += tam_isla;
                    }
                }
            }

            return {
                densidad_islas: num_islas / (TAM_REJILLA * TAM_REJILLA),
                tamano_promedio: num_islas > 0 ? total_atomos_sup / num_islas : 0,
                num_islas: num_islas,
                total_atomos: total_atomos_sup
            };
        }

        function calcular_propiedades_fisicas() {
            let altura_superficie = new Array(TAM_REJILLA).fill(null).map(() => new Array(TAM_REJILLA).fill(0));
            let altura_media = 0;

            // Calcular alturas
            for(let i=0; i<TAM_REJILLA; i++) {
                for(let j=0; j<TAM_REJILLA; j++) {
                    let h = find_z_max(i, j); // Nota: find_z_max devuelve 0 si no hay atomos (sustrato esta en 0 y 1)
                    // Ajuste: El sustrato es nivel 2 implicitamente en altura humana?
                    // El codigo Fortran inicializa con sustrato en Z=1 y Z=2 (indices 1 y 2).
                    // En JS indices 0 y 1. Si no hay nada, devuelve 0.
                    // Para rugosidad nos interesa la topologia real.
                    if (state.material[i][j][0] === -1) h = 0; // Base logica
                    
                    altura_superficie[i][j] = state.altura_max_local[i][j]; // Usamos el tracking directo
                    altura_media += altura_superficie[i][j];
                }
            }
            altura_media /= (TAM_REJILLA * TAM_REJILLA);

            // Rugosidad RMS
            let rms_sum = 0;
            let cobertura = 0;
            for(let i=0; i<TAM_REJILLA; i++) {
                for(let j=0; j<TAM_REJILLA; j++) {
                    rms_sum += Math.pow(altura_superficie[i][j] - altura_media, 2);
                    if (altura_superficie[i][j] > 2) cobertura++; // Mayor que sustrato
                }
            }
            
            let rugosidad_rms = Math.sqrt(rms_sum / (TAM_REJILLA * TAM_REJILLA));
            let cobertura_frac = cobertura / (TAM_REJILLA * TAM_REJILLA);

            // Anisotropia
            let diff_x = 0, diff_y = 0;
            for(let i=0; i<TAM_REJILLA; i++) {
                for(let j=0; j<TAM_REJILLA; j++) {
                    let nx = (i + 1) % TAM_REJILLA;
                    let ny = (j + 1) % TAM_REJILLA;
                    diff_x += Math.abs(altura_superficie[i][j] - altura_superficie[nx][j]);
                    diff_y += Math.abs(altura_superficie[i][j] - altura_superficie[i][ny]);
                }
            }
            diff_x /= (TAM_REJILLA * TAM_REJILLA);
            diff_y /= (TAM_REJILLA * TAM_REJILLA);
            let anisotropia = diff_y > 0 ? diff_x / diff_y : 1.0;

            return {
                rugosidad_rms,
                cobertura_frac,
                anisotropia
            };
        }

        function calcular_longitud_difusion() {
            if (state.difusiones > 0 && state.tiempo > 0) {
                return Math.sqrt(2.0 * state.difusiones / state.tiempo);
            }
            return 0.0;
        }

        // --- VISUALIZACION ---
        function setupCanvas() {
            canvas.width = TAM_REJILLA * 8; // Scale up
            canvas.height = TAM_REJILLA * 8;
            ctx.scale(8, 8); // Each "pixel" is 8x8 real pixels
        }

        function render() {
            ctx.clearRect(0, 0, TAM_REJILLA, TAM_REJILLA);
            
            // Colores basados en material ID
            const colors = {
                bg: '#0a0a0f',
                substrate: '#1f1f2e',
                cr: '#4ade80', // Greenish
                fe: '#fb923c'  // Orangeish
            };

            for(let i=0; i<TAM_REJILLA; i++) {
                for(let j=0; j<TAM_REJILLA; j++) {
                    let h = state.altura_max_local[i][j];
                    let val = state.material[i][j][h];

                    let color = colors.bg;
                    
                    if (val === -1) color = colors.substrate;
                    else if (val === 1) color = colors.cr;
                    else if (val === 2) color = colors.fe;
                    
                    // Simulacion de altura por brillo
                    if (val > 0) {
                        // Altura maxima es 30. Aclaramos un poco basado en altura.
                        let brightness = 1.0 + (h / ALTURA_MAX) * 0.5;
                        ctx.fillStyle = color; // Podriamos manipular el color, pero simple es mejor para pixel art
                        ctx.fillRect(j, i, 1, 1); // Nota: x=j, y=i para coordenadas canvas
                        
                        // Pequeno brillo
                        ctx.fillStyle = `rgba(255,255,255, ${h/ALTURA_MAX * 0.3})`;
                        ctx.fillRect(j, i, 1, 1);

                    } else {
                        ctx.fillStyle = color;
                        ctx.fillRect(j, i, 1, 1);
                    }
                }
            }
        }

        function updateUI() {
            document.getElementById('val-events').innerText = state.num_eventos;
            document.getElementById('val-time').innerText = state.tiempo.toFixed(2);
            
            let progress = (state.num_eventos / state.params.MAX_EVENTOS) * 100;
            document.getElementById('val-progress').innerText = Math.floor(progress);
            document.getElementById('progress-fill').style.width = progress + '%';

            document.getElementById('val-dep').innerText = state.depositos;
            document.getElementById('val-dif').innerText = state.difusiones;

            // Metricas complejas se calculan solo cada cierto tiempo por rendimiento
            if (state.num_eventos % 100 === 0) {
                let mec = calcular_mecanismos();
                let fis = calcular_propiedades_fisicas();
                let difL = calcular_longitud_difusion();

                document.getElementById('val-dens').innerText = mec.densidad_islas.toFixed(4);
                document.getElementById('val-size').innerText = mec.tamano_promedio.toFixed(2);
                document.getElementById('val-cov').innerText = (fis.cobertura_frac * 100).toFixed(1) + '%';
                document.getElementById('val-rms').innerText = fis.rugosidad_rms.toFixed(3);
                document.getElementById('val-aniso').innerText = fis.anisotropia.toFixed(3);
                document.getElementById('val-diflen').innerText = difL.toFixed(3);
            }
        }

        function log(msg) {
            const div = document.createElement('div');
            div.textContent = `> ${msg}`;
            logContainer.appendChild(div);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        // --- CONTROLADOR PRINCIPAL ---
        async function startSimulation() {
            if (state.running) return;
            
            // Leer inputs
            const matId = parseInt(document.getElementById('input-material').value);
            const modoId = parseInt(document.getElementById('input-modo').value);
            const maxEv = parseInt(document.getElementById('input-events').value);
            const corridas = parseInt(document.getElementById('input-corridas').value);

            const matProps = MATERIAL_PROPS[matId];
            
            // Preparar parametros
            // Nota: Fortran genera aleatorios dentro del loop de corridas.
            // Aqui hacemos una corrida interactiva.
            
            // Calculos de parametros (Fisica)
            let energia_difusion = matProps.E_DIF_MIN + (matProps.E_DIF_MAX - matProps.E_DIF_MIN) * Math.random();
            let prob_dif_const = Math.exp(-energia_difusion / (KB * TEMP_SUBSTRATO));
            let adhesion = matProps.ADHESION_BASE + 0.03 * Math.random();
            
            let energia_prom = 2.0, tasa_ev = 50000.0;
            if (modoId === 1) { energia_prom = 2.0; tasa_ev = 50000.0; }
            else if (modoId === 2) { energia_prom = 5.0; tasa_ev = 20000.0; }
            else { 
                tasa_ev = 10000.0 + 90000.0 * Math.random(); 
                energia_prom = 2.0 + 3.0 * Math.random();
            }

            state.params = {
                MATERIAL_ID: matId,
                MAX_EVENTOS: maxEv,
                prob_difusion_const: prob_dif_const,
                adhesion: adhesion,
                energia_promedio: energia_prom,
                tasa_eventos: tasa_ev
            };

            state.running = true;
            btnStart.disabled = true;
            btnStart.textContent = "SIMULANDO...";
            document.getElementById('status-badge').className = "status-badge status-running";
            document.getElementById('status-badge').textContent = "Running";
            
            inicializar_rejilla();
            render();
            
            log(`Inicio simulacion ${matProps.name} (Modo ${modoId})`);
            log(`E_dif: ${energia_difusion.toFixed(3)} eV, Tasa: ${tasa_ev.toFixed(0)}`);

            // Loop de simulacion
            // Usamos requestAnimationFrame o setImmediate para no bloquear UI
            const loop = () => {
                if (!state.running) return;

                // Batch de eventos para velocidad
                let batch = 50; 
                for(let i=0; i<batch; i++) {
                    let cont = simular_evento();
                    if (!cont) {
                        finishSimulation();
                        return;
                    }
                }

                render();
                updateUI();

                if (state.num_eventos < state.params.MAX_EVENTOS) {
                    setTimeout(loop, 0); // Cede control al navegador
                } else {
                    finishSimulation();
                }
            };

            loop();
        }

        function finishSimulation() {
            state.running = false;
            btnStart.disabled = false;
            btnStart.textContent = "INICIAR SIMULACION";
            document.getElementById('status-badge').className = "status-badge status-idle";
            document.getElementById('status-badge').textContent = "Completed";
            
            // Metricas finales
            let mec = calcular_mecanismos();
            let fis = calcular_propiedades_fisicas();
            log(`Completado. Depositos: ${state.depositos}, Difusiones: ${state.difusiones}`);
            log(`Rugosidad RMS final: ${fis.rugosidad_rms.toFixed(4)}`);
        }

        // Init
        setupCanvas();
        btnStart.addEventListener('click', startSimulation);
        inicializar_rejilla(); // Initialize empty grid on load
        render();

    </script>
</body>
</html>
